# ============================================================================
# Azure Pipeline for TaskMaster.DocumentService
# ============================================================================
# Document processing microservice for templates, storage, and content
# Standardized to match TaskMaster.Platform pattern (WI #3519)
# ============================================================================

trigger:
  branches:
    include:
      - main
  paths:
    exclude:
      - '**/*.md'
      - 'docs/**'
      - '.github/**'

pr:
  branches:
    include:
      - main

# Use self-hosted agents for consistency
pool:
  name: TaskMaster-SelfHosted

variables:
  - group: SemanticRelease-Variables
  - name: buildConfiguration
    value: 'Release'
  - name: dotnetVersion
    value: '10.0.x'
  - name: acrName
    value: 'tmcrprodeus2'
  - name: imageName
    value: 'documentservice-api'
  - name: sonarQubeServiceConnection
    value: 'SonarQube-TaskMaster'
  - name: sonarQubeProjectKey
    value: 'taskmaster-documentservice'
  - name: sonarQubeProjectName
    value: 'TaskMaster DocumentService'
  - name: appVersionsApiUrl
    value: 'https://taskmaster-platform.thankfulsand-8986c25c.eastus2.azurecontainerapps.io/api/v1/versions'

stages:
  # ============================================================================
  # Stage 1: Build and Test
  # ============================================================================
  - stage: Build
    displayName: 'Build & Test'
    jobs:
      - job: BuildTest
        displayName: 'Build, Test, Analyze'
        steps:
          - checkout: self
            fetchDepth: 0

          # Setup .NET
          - task: UseDotNet@2
            displayName: 'Setup .NET SDK'
            inputs:
              version: '$(dotnetVersion)'

          # SonarQube Prepare
          - task: SonarQubePrepare@7
            displayName: 'SonarQube Prepare'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              SonarQube: '$(sonarQubeServiceConnection)'
              scannerMode: 'dotnet'
              projectKey: '$(sonarQubeProjectKey)'
              projectName: '$(sonarQubeProjectName)'
              extraProperties: |
                sonar.cs.opencover.reportsPaths=$(Agent.TempDirectory)/**/coverage.opencover.xml
                sonar.coverage.exclusions=**/Migrations/**,**/wwwroot/**

          # Cache NuGet packages
          - task: Cache@2
            displayName: 'Cache NuGet packages'
            inputs:
              key: 'nuget | "$(Agent.OS)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)"
              path: '$(Pipeline.Workspace)/.nuget/packages'
            continueOnError: true

          # Authenticate with Azure Artifacts NuGet feed
          - task: NuGetAuthenticate@1
            displayName: 'Authenticate NuGet'

          # Restore
          - task: DotNetCoreCLI@2
            displayName: 'Restore'
            inputs:
              command: 'restore'
              projects: 'TaskMaster.DocumentService.sln'
              feedsToUse: 'config'
              nugetConfigPath: 'nuget.config'

          # Build
          - task: DotNetCoreCLI@2
            displayName: 'Build'
            inputs:
              command: 'build'
              projects: 'TaskMaster.DocumentService.sln'
              arguments: '-c $(buildConfiguration) --no-restore'

          # Test with coverage
          - task: DotNetCoreCLI@2
            displayName: 'Test'
            inputs:
              command: 'test'
              projects: '**/tests/**/*.csproj'
              arguments: '-c $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover'
              publishTestResults: true

          # Publish coverage
          - task: PublishCodeCoverageResults@2
            displayName: 'Publish Coverage'
            inputs:
              summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'

          # ============================================================================
          # Publish Application for Container Build (main branch only)
          # ============================================================================
          # Pre-publish binaries so BuildContainer stage doesn't need NuGet restore
          # This fixes NuGet 401 errors and speeds up container builds
          # ============================================================================
          - task: DotNetCoreCLI@2
            displayName: 'Publish Application'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              command: 'publish'
              publishWebProjects: false
              projects: 'src/TaskMaster.DocumentService.Api/TaskMaster.DocumentService.Api.csproj'
              arguments: '-c $(buildConfiguration) --no-build -o $(Build.ArtifactStagingDirectory)/publish'
              zipAfterPublish: false
              modifyOutputPath: false

          - task: PublishPipelineArtifact@1
            displayName: 'Upload Build Artifacts'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/publish'
              artifact: 'app-binaries'
              publishLocation: 'pipeline'

          # ============================================================================
          # Remove branch.name for SonarQube Community Edition
          # ============================================================================
          - script: |
              FILTERED_PARAMS=$(echo $SONARQUBE_SCANNER_PARAMS | sed 's/"sonar.branch.name":"[^"]*"\,//g')
              echo "##vso[task.setvariable variable=SONARQUBE_SCANNER_PARAMS]$FILTERED_PARAMS"
            displayName: 'Remove branch.name for SonarQube CE'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')

          # SonarQube Analyze
          - task: SonarQubeAnalyze@7
            displayName: 'Run SonarQube Code Analysis'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              jdkversion: 'JAVA_HOME_17_X64'

          # SonarQube Publish
          - task: SonarQubePublish@7
            displayName: 'SonarQube Publish'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              pollingTimeoutSec: '300'

          # Quality Gate (PR only - breaks build if fails)
          - task: sonar-buildbreaker@8
            displayName: 'Break build on Quality Gate failure'
            inputs:
              SonarQube: '$(sonarQubeServiceConnection)'
            condition: and(succeeded(), eq(variables['Build.Reason'], 'PullRequest'))

  # ============================================================================
  # Stage 2: Semantic Version
  # ============================================================================
  - stage: SemanticRelease
    displayName: 'Get Semantic Version'
    dependsOn: Build
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: Release
        displayName: 'Determine Version'
        steps:
          - checkout: self
            fetchDepth: 0

          - script: |
              # Get latest semantic version tag
              LATEST_TAG=$(git tag --sort=-v:refname | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+' | head -1)
              
              if [ -z "$LATEST_TAG" ]; then
                VERSION="1.0.0"
                echo "No existing tags found, using default version: $VERSION"
              else
                VERSION="${LATEST_TAG#v}"
                echo "Found latest tag: $LATEST_TAG -> Version: $VERSION"
              fi
              
              echo "##vso[task.setvariable variable=semanticVersion;isOutput=true]$VERSION"
              echo "Semantic Version: $VERSION"
            name: semver
            displayName: 'Extract Semantic Version'

  # ============================================================================
  # Stage 3: Build Container (Runtime-only Dockerfile - no NuGet needed)
  # ============================================================================
  # Uses pre-built binaries from Build stage - no SDK or NuGet restore in container
  # This pattern avoids Azure Artifacts auth issues in ACR Tasks
  # ============================================================================
  - stage: BuildContainer
    displayName: 'Build Container Image'
    dependsOn: 
      - Build
      - SemanticRelease
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    variables:
      semanticVersion: $[ stageDependencies.SemanticRelease.Release.outputs['semver.semanticVersion'] ]
    jobs:
      - job: BuildPush
        displayName: 'Build and Push to ACR'
        steps:
          - checkout: self
            fetchDepth: 1

          # Download pre-built binaries from Build stage
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Build Artifacts'
            inputs:
              buildType: 'current'
              artifactName: 'app-binaries'
              targetPath: '$(Pipeline.Workspace)/publish'

          # Create runtime-only Dockerfile (no SDK, no restore needed)
          - script: |
              mkdir -p $(Pipeline.Workspace)/docker-context
              cp -r $(Pipeline.Workspace)/publish $(Pipeline.Workspace)/docker-context/
              
              cd $(Pipeline.Workspace)/docker-context
              cat > Dockerfile << 'DOCKERFILE'
              FROM mcr.microsoft.com/dotnet/aspnet:10.0
              WORKDIR /app
              
              # Install curl for health checks
              RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
              
              # Copy pre-built binaries
              COPY publish/ .
              
              # Configure environment
              ENV ASPNETCORE_ENVIRONMENT=Production
              ENV DOTNET_RUNNING_IN_CONTAINER=true
              
              # Create non-root user
              RUN useradd -m appuser && chown -R appuser:appuser /app
              USER appuser
              
              EXPOSE 8080
              
              # Health check
              HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
                  CMD curl -f http://localhost:8080/health || exit 1
              
              ENTRYPOINT ["dotnet", "TaskMaster.DocumentService.Api.dll"]
              DOCKERFILE
              
              echo "=== Dockerfile created ==="
              cat Dockerfile
              echo ""
              echo "=== Context contents ==="
              ls -la
              ls -la publish/ | head -20
            displayName: 'Create Runtime Dockerfile'

          # Build and push using az acr build
          - task: AzureCLI@2
            displayName: 'Build Container via ACR Tasks'
            inputs:
              azureSubscription: 'Azure-TaskMaster-Production'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                
                SEMANTIC_VERSION="$(semanticVersion)"
                VERSION="${SEMANTIC_VERSION:-$(Build.BuildId)}"
                COMMIT_SHA=$(Build.SourceVersion)
                SHORT_SHA=${COMMIT_SHA:0:7}
                
                echo "=========================================="
                echo "Building DocumentService Container"
                echo "Registry: $(acrName)"
                echo "Image: $(imageName)"
                echo "Version: $VERSION"
                echo "Commit: $SHORT_SHA"
                echo "=========================================="
                
                cd $(Pipeline.Workspace)/docker-context
                
                az acr build \
                  --registry $(acrName) \
                  --image $(imageName):$VERSION \
                  --image $(imageName):$SHORT_SHA \
                  --image $(imageName):latest \
                  --file Dockerfile \
                  .
                
                echo ""
                echo "✅ Container built and pushed successfully"
                echo "Tags: $VERSION, $SHORT_SHA, latest"

          # Record version in AppVersions
          - task: AzureCLI@2
            displayName: 'Record Version in AppVersions'
            inputs:
              azureSubscription: 'Azure-TaskMaster-Production'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                
                SEMANTIC_VERSION="$(semanticVersion)"
                VERSION="${SEMANTIC_VERSION:-$(Build.BuildId)}"
                COMMIT_SHA=$(Build.SourceVersion)
                IMAGE_TAG="$(acrName).azurecr.io/$(imageName):$VERSION"
                BUILD_NUMBER="$(Build.BuildNumber)"
                
                # Get API key from Key Vault
                API_KEY=$(az keyvault secret show --vault-name tm-kv-prod-eus2 --name TASKMASTER-SERVICE-API-KEY --query value -o tsv)
                
                JSON_PAYLOAD=$(jq -n \
                  --arg appName "$(imageName)" \
                  --arg version "$VERSION" \
                  --arg commitSha "$COMMIT_SHA" \
                  --arg imageTag "$IMAGE_TAG" \
                  --arg buildNumber "$BUILD_NUMBER" \
                  --arg releasedBy "Azure DevOps" \
                  --arg releaseNotes "Build from commit $COMMIT_SHA" \
                  '{
                    appName: $appName,
                    version: $version,
                    commitSha: $commitSha,
                    imageTag: $imageTag,
                    buildNumber: $buildNumber,
                    releasedBy: $releasedBy,
                    releaseNotes: $releaseNotes
                  }')
                
                echo "Recording version in AppVersions API..."
                HTTP_STATUS=$(curl -s -o /tmp/response.txt -w "%{http_code}" \
                  -X POST "$(appVersionsApiUrl)" \
                  -H "Content-Type: application/json" \
                  -H "X-API-Key: $API_KEY" \
                  -d "$JSON_PAYLOAD")
                
                if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
                  echo "✅ Version recorded successfully (HTTP $HTTP_STATUS)"
                else
                  echo "⚠️ Failed to record version (HTTP $HTTP_STATUS)"
                  cat /tmp/response.txt
                fi

  # ============================================================================
  # Stage 4: Deploy (DISABLED)
  # ============================================================================
  - stage: Deploy
    displayName: 'Deploy to ACA (DISABLED)'
    dependsOn: BuildContainer
    # DISABLED: Deploy handled by GitHub Actions scheduled workflow
    condition: and(eq(1, 0), succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: DeployACA
        displayName: 'Deploy to Azure Container Apps'
        steps:
          - script: echo "Deploy stage disabled - use scheduled deployment"
