# ============================================================================
# Azure Pipeline for TaskMaster.DocumentService
# ============================================================================
# Document processing microservice for templates, storage, and content
# Standardized to match TaskMaster.Platform pattern (WI #3519)
# ============================================================================

trigger:
  branches:
    include:
      - main
      # - fix/* # DISABLED: Redundant with PR builds
      # - feature/* # DISABLED: Redundant with PR builds
  paths:
    exclude:
      - '**/*.md'
      - 'docs/**'
      - '.github/**'

pr:
  branches:
    include:
      - main

# Use self-hosted agents for consistency
pool:
  name: TaskMaster-SelfHosted

variables:
  - group: SemanticRelease-Variables
  - name: buildConfiguration
    value: 'Release'
  - name: dotnetVersion
    value: '9.0.x'
  - name: acrName
    value: 'tmcrprodeus2'
  - name: imageName
    value: 'documentservice-api'
  - name: sonarQubeServiceConnection
    value: 'SonarQube-TaskMaster'
  - name: sonarQubeProjectKey
    value: 'taskmaster-documentservice'
  - name: sonarQubeProjectName
    value: 'TaskMaster DocumentService'
  - name: appVersionsApiUrl
    value: 'https://taskmaster-platform.thankfulsand-8986c25c.eastus2.azurecontainerapps.io/api/v1/versions'

stages:
  # ============================================================================
  # Stage 1: Build and Test
  # ============================================================================
  - stage: Build
    displayName: 'Build & Test'
    jobs:
      - job: BuildTest
        displayName: 'Build, Test, Analyze'
        steps:
          - checkout: self
            fetchDepth: 0

          # Setup .NET
          - task: UseDotNet@2
            displayName: 'Setup .NET SDK'
            inputs:
              version: '$(dotnetVersion)'

          # SonarQube Prepare
          - task: SonarQubePrepare@7
            displayName: 'SonarQube Prepare'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              SonarQube: '$(sonarQubeServiceConnection)'
              scannerMode: 'dotnet'
              projectKey: '$(sonarQubeProjectKey)'
              projectName: '$(sonarQubeProjectName)'
              extraProperties: |
                sonar.cs.opencover.reportsPaths=$(Agent.TempDirectory)/**/coverage.opencover.xml
                sonar.coverage.exclusions=**/Migrations/**,**/wwwroot/**

          # Cache NuGet packages
          - task: Cache@2
            displayName: 'Cache NuGet packages'
            inputs:
              key: 'nuget | "$(Agent.OS)" | **/packages.lock.json'
              restoreKeys: |
                nuget | "$(Agent.OS)"
              path: '$(Pipeline.Workspace)/.nuget/packages'

          # Restore
          - task: DotNetCoreCLI@2
            displayName: 'Restore'
            inputs:
              command: 'restore'
              projects: '**/*.csproj'

          # Build
          - task: DotNetCoreCLI@2
            displayName: 'Build'
            inputs:
              command: 'build'
              projects: '**/*.csproj'
              arguments: '-c $(buildConfiguration) --no-restore'

          # Test with coverage
          - task: DotNetCoreCLI@2
            displayName: 'Test'
            inputs:
              command: 'test'
              projects: '**/tests/**/*.csproj'
              arguments: '-c $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" --results-directory $(Agent.TempDirectory)/TestResults -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover'
              publishTestResults: true

          # Publish coverage
          - task: PublishCodeCoverageResults@2
            displayName: 'Publish Coverage'
            inputs:
              summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'

          # SonarQube Analyze
          - task: SonarQubeAnalyze@7
            displayName: 'SonarQube Analyze'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')

          # SonarQube Publish
          - task: SonarQubePublish@7
            displayName: 'SonarQube Publish'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              pollingTimeoutSec: '300'

          # Quality Gate (PR only - breaks build if fails)
          - task: sonar-buildbreaker@8
            displayName: 'Break build on Quality Gate failure'
            inputs:
              SonarQube: '$(sonarQubeServiceConnection)'
            condition: and(succeeded(), eq(variables['Build.Reason'], 'PullRequest'))

  # ============================================================================
  # Stage 2: Semantic Version
  # ============================================================================
  - stage: SemanticRelease
    displayName: 'Get Semantic Version'
    dependsOn: Build
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: Release
        displayName: 'Determine Version'
        steps:
          - checkout: self
            fetchDepth: 0

          - script: |
              # Get latest semantic version tag
              LATEST_TAG=$(git tag --sort=-v:refname | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+' | head -1)
              
              if [ -z "$LATEST_TAG" ]; then
                VERSION="1.0.0"
                echo "No existing tags found, using default version: $VERSION"
              else
                VERSION="${LATEST_TAG#v}"
                echo "Found latest tag: $LATEST_TAG -> Version: $VERSION"
              fi
              
              echo "##vso[task.setvariable variable=semanticVersion;isOutput=true]$VERSION"
              echo "Semantic Version: $VERSION"
            name: semver
            displayName: 'Extract Semantic Version'

  # ============================================================================
  # Stage 3: Build Container
  # ============================================================================
  - stage: BuildContainer
    displayName: 'Build Container Image'
    dependsOn: 
      - Build
      - SemanticRelease
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    variables:
      semanticVersion: $[ stageDependencies.SemanticRelease.Release.outputs['semver.semanticVersion'] ]
    jobs:
      - job: BuildPush
        displayName: 'Build and Push to ACR'
        steps:
          - checkout: self
            fetchDepth: 0

          # Build using ACR Tasks
          - task: AzureCLI@2
            displayName: 'Build Container via ACR Tasks'
            inputs:
              azureSubscription: 'Azure-TaskMaster-Production'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                
                SEMANTIC_VERSION="$(semanticVersion)"
                VERSION="${SEMANTIC_VERSION:-$(Build.BuildId)}"
                COMMIT_SHA=$(Build.SourceVersion)
                SHORT_SHA=${COMMIT_SHA:0:7}
                
                echo "=========================================="
                echo "Building DocumentService Container"
                echo "Registry: $(acrName)"
                echo "Image: $(imageName)"
                echo "Version: $VERSION"
                echo "Commit: $SHORT_SHA"
                echo "=========================================="
                
                cd src/TaskMaster.DocumentService.Api
                
                az acr build \
                  --registry $(acrName) \
                  --image $(imageName):$VERSION \
                  --image $(imageName):$SHORT_SHA \
                  --image $(imageName):latest \
                  --file Dockerfile \
                  ../..
                
                echo ""
                echo "✅ Container built and pushed successfully"
                echo "Tags: $VERSION, $SHORT_SHA, latest"

          # Record version in AppVersions
          - task: AzureCLI@2
            displayName: 'Record Version in AppVersions'
            inputs:
              azureSubscription: 'Azure-TaskMaster-Production'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                
                SEMANTIC_VERSION="$(semanticVersion)"
                VERSION="${SEMANTIC_VERSION:-$(Build.BuildId)}"
                COMMIT_SHA=$(Build.SourceVersion)
                IMAGE_TAG="$(acrName).azurecr.io/$(imageName):$VERSION"
                BUILD_NUMBER="$(Build.BuildNumber)"
                
                # Get API key from Key Vault
                API_KEY=$(az keyvault secret show --vault-name tm-kv-prod-eus2 --name TASKMASTER-SERVICE-API-KEY --query value -o tsv)
                
                JSON_PAYLOAD=$(jq -n \
                  --arg appName "$(imageName)" \
                  --arg version "$VERSION" \
                  --arg commitSha "$COMMIT_SHA" \
                  --arg imageTag "$IMAGE_TAG" \
                  --arg buildNumber "$BUILD_NUMBER" \
                  --arg releasedBy "Azure DevOps" \
                  --arg releaseNotes "Build from commit $COMMIT_SHA" \
                  '{
                    appName: $appName,
                    version: $version,
                    commitSha: $commitSha,
                    imageTag: $imageTag,
                    buildNumber: $buildNumber,
                    releasedBy: $releasedBy,
                    releaseNotes: $releaseNotes
                  }')
                
                echo "Recording version in AppVersions API..."
                HTTP_STATUS=$(curl -s -o /tmp/response.txt -w "%{http_code}" \
                  -X POST "$(appVersionsApiUrl)" \
                  -H "Content-Type: application/json" \
                  -H "X-API-Key: $API_KEY" \
                  -d "$JSON_PAYLOAD")
                
                if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
                  echo "✅ Version recorded successfully (HTTP $HTTP_STATUS)"
                else
                  echo "⚠️ Failed to record version (HTTP $HTTP_STATUS)"
                  cat /tmp/response.txt
                fi

  # ============================================================================
  # Stage 4: Deploy (DISABLED)
  # ============================================================================
  - stage: Deploy
    displayName: 'Deploy to ACA (DISABLED)'
    dependsOn: BuildContainer
    # DISABLED: Deploy handled by GitHub Actions scheduled workflow
    condition: and(eq(1, 0), succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: DeployACA
        displayName: 'Deploy to Azure Container Apps'
        steps:
          - script: echo "Deploy stage disabled - use scheduled deployment"
