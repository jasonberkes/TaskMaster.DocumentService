# ============================================================================
# Azure Pipeline for TaskMaster.DocumentService
# ============================================================================
# Document processing microservice for templates, storage, and content
# Standardized to match TaskMaster.Platform pattern (WI #3519)
#
# Build Strategy:
# - PR to main: Build & Test only (validation)
# - Scheduled (6am/12pm/6pm/12am CST): Build container IF code changed
# - NO automatic builds on merge to main (only scheduled)
# ============================================================================

# Disable CI trigger - only build on schedule or PR
trigger: none

pr:
  branches:
    include:
      - main

# Scheduled builds - only if code changed since last build
schedules:
  - cron: '0 12 * * *'  # 6:00 AM CST (12:00 UTC)
    displayName: 'Scheduled Build - 6am CST'
    branches:
      include:
        - main
    always: false
  - cron: '0 18 * * *'  # 12:00 PM CST (18:00 UTC)
    displayName: 'Scheduled Build - 12pm CST'
    branches:
      include:
        - main
    always: false
  - cron: '0 0 * * *'   # 6:00 PM CST (00:00 UTC next day)
    displayName: 'Scheduled Build - 6pm CST'
    branches:
      include:
        - main
    always: false
  - cron: '0 6 * * *'   # 12:00 AM CST (06:00 UTC)
    displayName: 'Scheduled Build - 12am CST'
    branches:
      include:
        - main
    always: false

# Use self-hosted agents for consistency
pool:
  name: TaskMaster-SelfHosted

variables:
  - group: SemanticRelease-Variables
  - name: buildConfiguration
    value: 'Release'
  - name: dotnetVersion
    value: '10.0.x'
  - name: acrName
    value: 'tmcrprodeus2'
  - name: imageName
    value: 'documentservice-api'
  - name: sonarQubeServiceConnection
    value: 'SonarQube-TaskMaster'
  - name: sonarQubeProjectKey
    value: 'taskmaster-documentservice'
  - name: sonarQubeProjectName
    value: 'TaskMaster DocumentService'
  - name: appVersionsApiUrl
    value: 'https://taskmaster-platform.thankfulsand-8986c25c.eastus2.azurecontainerapps.io/api/v1/versions'
  - name: resourceGroup
    value: 'tm-rg-prod-eus2'
  - name: containerAppName
    value: 'tm-documentservice-prod-eus2'

stages:
  # ============================================================================
  # Stage 1: Build and Test
  # ============================================================================
  - stage: Build
    displayName: 'Build & Test'
    jobs:
      - job: BuildTest
        displayName: 'Build, Test, Analyze'
        steps:
          - checkout: self
            fetchDepth: 0

          # Setup .NET
          - task: UseDotNet@2
            displayName: 'Setup .NET SDK'
            inputs:
              version: '$(dotnetVersion)'

          # SonarQube Prepare
          - task: SonarQubePrepare@7
            displayName: 'SonarQube Prepare'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              SonarQube: '$(sonarQubeServiceConnection)'
              scannerMode: 'dotnet'
              projectKey: '$(sonarQubeProjectKey)'
              projectName: '$(sonarQubeProjectName)'
              extraProperties: |
                sonar.cs.opencover.reportsPaths=$(Agent.TempDirectory)/**/coverage.opencover.xml
                sonar.coverage.exclusions=**/Migrations/**,**/wwwroot/**

          # Cache NuGet packages
          - task: Cache@2
            displayName: 'Cache NuGet packages'
            inputs:
              key: 'nuget | "$(Agent.OS)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)"
              path: '$(Pipeline.Workspace)/.nuget/packages'
            continueOnError: true

          # Authenticate with Azure Artifacts NuGet feed
          - task: NuGetAuthenticate@1
            displayName: 'Authenticate NuGet'

          # Restore
          - task: DotNetCoreCLI@2
            displayName: 'Restore'
            inputs:
              command: 'restore'
              projects: 'TaskMaster.DocumentService.sln'
              feedsToUse: 'config'
              nugetConfigPath: 'nuget.config'

          # Build
          - task: DotNetCoreCLI@2
            displayName: 'Build'
            inputs:
              command: 'build'
              projects: 'TaskMaster.DocumentService.sln'
              arguments: '-c $(buildConfiguration) --no-restore'

          # Test with coverage
          - task: DotNetCoreCLI@2
            displayName: 'Test'
            inputs:
              command: 'test'
              projects: '**/tests/**/*.csproj'
              arguments: '-c $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover'
              publishTestResults: true

          # Publish coverage
          - task: PublishCodeCoverageResults@2
            displayName: 'Publish Coverage'
            inputs:
              summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'

          # ============================================================================
          # Publish Application for Container Build (main branch only)
          # ============================================================================
          # Pre-publish binaries so BuildContainer stage doesn't need NuGet restore
          # This fixes NuGet 401 errors and speeds up container builds
          # ============================================================================
          - task: DotNetCoreCLI@2
            displayName: 'Publish Application'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              command: 'publish'
              publishWebProjects: false
              projects: 'src/TaskMaster.DocumentService.Api/TaskMaster.DocumentService.Api.csproj'
              arguments: '-c $(buildConfiguration) --no-build -o $(Build.ArtifactStagingDirectory)/publish'
              zipAfterPublish: false
              modifyOutputPath: false

          - task: PublishPipelineArtifact@1
            displayName: 'Upload Build Artifacts'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/publish'
              artifact: 'app-binaries'
              publishLocation: 'pipeline'

          # ============================================================================
          # Remove branch.name for SonarQube Community Edition
          # ============================================================================
          - script: |
              FILTERED_PARAMS=$(echo $SONARQUBE_SCANNER_PARAMS | sed 's/"sonar.branch.name":"[^"]*"\,//g')
              echo "##vso[task.setvariable variable=SONARQUBE_SCANNER_PARAMS]$FILTERED_PARAMS"
            displayName: 'Remove branch.name for SonarQube CE'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')

          # SonarQube Analyze
          - task: SonarQubeAnalyze@7
            displayName: 'Run SonarQube Code Analysis'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              jdkversion: 'JAVA_HOME_17_X64'

          # SonarQube Publish
          - task: SonarQubePublish@7
            displayName: 'SonarQube Publish'
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              pollingTimeoutSec: '300'

          # Quality Gate (PR only - breaks build if fails)
          - task: sonar-buildbreaker@8
            displayName: 'Break build on Quality Gate failure'
            inputs:
              SonarQube: '$(sonarQubeServiceConnection)'
            condition: "false"  # Disabled - SonarQube only runs on main branch

  # ============================================================================
  # Stage 2: Semantic Version
  # ============================================================================
  - stage: SemanticRelease
    displayName: 'Get Semantic Version'
    dependsOn: Build
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: Release
        displayName: 'Determine Version'
        steps:
          - checkout: self
            fetchDepth: 0

          - script: |
              # Get latest semantic version tag
              LATEST_TAG=$(git tag --sort=-v:refname | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+' | head -1)
              
              if [ -z "$LATEST_TAG" ]; then
                VERSION="1.0.0"
                echo "No existing tags found, using default version: $VERSION"
              else
                VERSION="${LATEST_TAG#v}"
                echo "Found latest tag: $LATEST_TAG -> Version: $VERSION"
              fi
              
              echo "##vso[task.setvariable variable=semanticVersion;isOutput=true]$VERSION"
              echo "Semantic Version: $VERSION"
            name: semver
            displayName: 'Extract Semantic Version'

  # ============================================================================
  # Stage 3: Build Container (Runtime-only Dockerfile - no NuGet needed)
  # ============================================================================
  # Uses pre-built binaries from Build stage - no SDK or NuGet restore in container
  # This pattern avoids Azure Artifacts auth issues in ACR Tasks
  # ============================================================================
  - stage: BuildContainer
    displayName: 'Build Container Image'
    dependsOn: 
      - Build
      - SemanticRelease
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    variables:
      semanticVersion: $[ stageDependencies.SemanticRelease.Release.outputs['semver.semanticVersion'] ]
    jobs:
      - job: BuildPush
        displayName: 'Build and Push to ACR'
        steps:
          - checkout: self
            fetchDepth: 1

          # Download pre-built binaries from Build stage
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Build Artifacts'
            inputs:
              buildType: 'current'
              artifactName: 'app-binaries'
              targetPath: '$(Pipeline.Workspace)/publish'

          # Create runtime-only Dockerfile (no SDK, no restore needed)
          - script: |
              mkdir -p $(Pipeline.Workspace)/docker-context
              cp -r $(Pipeline.Workspace)/publish $(Pipeline.Workspace)/docker-context/
              
              cd $(Pipeline.Workspace)/docker-context
              cat > Dockerfile << 'DOCKERFILE'
              FROM mcr.microsoft.com/dotnet/aspnet:10.0
              WORKDIR /app
              
              # Install curl for health checks
              RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
              
              # Copy pre-built binaries
              COPY publish/ .
              
              # Configure environment
              ENV ASPNETCORE_ENVIRONMENT=Production
              ENV DOTNET_RUNNING_IN_CONTAINER=true
              
              # Create non-root user
              RUN useradd -m appuser && chown -R appuser:appuser /app
              USER appuser
              
              EXPOSE 8080
              
              # Health check
              HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
                  CMD curl -f http://localhost:8080/health || exit 1
              
              ENTRYPOINT ["dotnet", "TaskMaster.DocumentService.Api.dll"]
              DOCKERFILE
              
              echo "=== Dockerfile created ==="
              cat Dockerfile
              echo ""
              echo "=== Context contents ==="
              ls -la
              ls -la publish/ | head -20
            displayName: 'Create Runtime Dockerfile'

          # Build and push using az acr build
          - task: AzureCLI@2
            displayName: 'Build Container via ACR Tasks'
            inputs:
              azureSubscription: 'Azure-TaskMaster-Production'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                
                SEMANTIC_VERSION="$(semanticVersion)"
                VERSION="${SEMANTIC_VERSION:-$(Build.BuildId)}"
                COMMIT_SHA=$(Build.SourceVersion)
                SHORT_SHA=${COMMIT_SHA:0:7}
                
                echo "=========================================="
                echo "Building DocumentService Container"
                echo "Registry: $(acrName)"
                echo "Image: $(imageName)"
                echo "Version: $VERSION"
                echo "Commit: $SHORT_SHA"
                echo "=========================================="
                
                cd $(Pipeline.Workspace)/docker-context
                
                az acr build \
                  --registry $(acrName) \
                  --image $(imageName):$VERSION \
                  --image $(imageName):$SHORT_SHA \
                  --image $(imageName):latest \
                  --file Dockerfile \
                  .
                
                echo ""
                echo "âœ… Container built and pushed successfully"
                echo "Tags: $VERSION, $SHORT_SHA, latest"

          # Record version in AppVersions
          - task: AzureCLI@2
            displayName: 'Record Version in AppVersions'
            inputs:
              azureSubscription: 'Azure-TaskMaster-Production'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                
                SEMANTIC_VERSION="$(semanticVersion)"
                VERSION="${SEMANTIC_VERSION:-$(Build.BuildId)}"
                COMMIT_SHA=$(Build.SourceVersion)
                IMAGE_TAG="$(acrName).azurecr.io/$(imageName):$VERSION"
                BUILD_NUMBER="$(Build.BuildNumber)"
                
                # Get API key from Key Vault
                API_KEY=$(az keyvault secret show --vault-name tm-kv-prod-eus2 --name TASKMASTER-SERVICE-API-KEY --query value -o tsv)
                
                JSON_PAYLOAD=$(jq -n \
                  --arg appName "$(imageName)" \
                  --arg version "$VERSION" \
                  --arg commitSha "$COMMIT_SHA" \
                  --arg imageTag "$IMAGE_TAG" \
                  --arg buildNumber "$BUILD_NUMBER" \
                  --arg releasedBy "Azure DevOps" \
                  --arg releaseNotes "Build from commit $COMMIT_SHA" \
                  '{
                    appName: $appName,
                    version: $version,
                    commitSha: $commitSha,
                    imageTag: $imageTag,
                    buildNumber: $buildNumber,
                    releasedBy: $releasedBy,
                    releaseNotes: $releaseNotes
                  }')
                
                echo "Recording version in AppVersions API..."
                HTTP_STATUS=$(curl -s -o /tmp/response.txt -w "%{http_code}" \
                  -X POST "$(appVersionsApiUrl)" \
                  -H "Content-Type: application/json" \
                  -H "X-API-Key: $API_KEY" \
                  -d "$JSON_PAYLOAD")
                
                if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
                  echo "âœ… Version recorded successfully (HTTP $HTTP_STATUS)"
                else
                  echo "âš ï¸ Failed to record version (HTTP $HTTP_STATUS)"
                  cat /tmp/response.txt
                fi

  # ============================================================================
  # Stage 4: Deploy (DISABLED)
  # ============================================================================
  # ============================================================================
  # Stage 4: Deploy - Blue/Green Deployment to Azure Container Apps
  # ============================================================================
  # Uses blue-green deployment script for zero-downtime updates.
  # Only runs on scheduled builds when there's a new container to deploy.
  # ============================================================================
  - stage: Deploy
    displayName: 'Deploy to ACA (Blue/Green)'
    dependsOn:
      - Build
      - SemanticRelease
      - BuildContainer
    # Only run on Schedule or Manual builds, AND only if BuildContainer succeeded
    condition: |
      and(
        or(eq(variables['Build.Reason'], 'Schedule'), eq(variables['Build.Reason'], 'Manual')),
        in(dependencies.Build.result, 'Succeeded', 'SucceededWithIssues'),
        in(dependencies.BuildContainer.result, 'Succeeded', 'SucceededWithIssues')
      )
    variables:
      semanticVersion: $[ stageDependencies.SemanticRelease.Release.outputs['semver.semanticVersion'] ]
    jobs:
      - deployment: DeployACA
        displayName: 'Blue/Green Deploy to Container App'
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  clean: true
                  fetchDepth: 0

                # ============================================================
                # Blue/Green Deployment using deploy script
                # ============================================================
                - task: AzureCLI@2
                  displayName: 'Execute Blue/Green Deployment'
                  inputs:
                    azureSubscription: 'Azure-TaskMaster-Production'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      set -e
                      
                      SEMANTIC_VERSION="$(semanticVersion)"
                      VERSION="${SEMANTIC_VERSION:-$(Build.BuildId)}"
                      echo "ðŸš€ Starting Blue/Green deployment for version: $VERSION"
                      
                      # Make script executable
                      chmod +x ./scripts/deploy-bluegreen.sh
                      
                      # Execute blue-green deployment (skip gradual for scheduled deploys)
                      ./scripts/deploy-bluegreen.sh "$VERSION" --skip-logging
                      
                      echo "âœ… Blue/Green deployment completed successfully"
                  env:
                    RESOURCE_GROUP: $(resourceGroup)
                    CONTAINER_APP_NAME: $(containerAppName)
                    ACR_REGISTRY: $(acrName).azurecr.io
                    REPOSITORY_NAME: $(imageName)

                # ============================================================
                # Record deployment in AppVersions table
                # ============================================================
                - task: AzureCLI@2
                  displayName: 'Mark Version as Deployed'
                  inputs:
                    azureSubscription: 'Azure-TaskMaster-Production'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      set -e
                      
                      SEMANTIC_VERSION="$(semanticVersion)"
                      VERSION="${SEMANTIC_VERSION:-$(Build.BuildId)}"
                      
                      # Get API key from Key Vault
                      API_KEY=$(az keyvault secret show --vault-name tm-kv-prod-eus2 --name TASKMASTER-SERVICE-API-KEY --query value -o tsv)
                      
                      echo "ðŸ“ Recording deployment: $VERSION"
                      
                      # Mark as deployed in AppVersions
                      HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/api_response.json \
                        --max-time 30 --retry 2 --retry-delay 1 \
                        -X PUT "$(appVersionsApiUrl)/$(imageName)/$VERSION/deployed" \
                        -H "Content-Type: application/json" \
                        -H "X-API-Key: $API_KEY")
                      
                      if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 204 ]; then
                        echo "âœ… Version $VERSION marked as deployed"
                      else
                        echo "âš ï¸ Failed to mark as deployed (HTTP $HTTP_CODE) - continuing"
                        cat /tmp/api_response.json || true
                      fi
                  continueOnError: true
